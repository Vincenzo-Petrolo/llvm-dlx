Args: ../build/bin/llc -debug -march=dlx32 -O2 -filetype=asm main.bc -o main.S 
	discovered a new reachable node %entry
	discovered a new reachable node %entry
	discovered a new reachable node %for.body.preheader
	discovered a new reachable node %for.cond.cleanup
	discovered a new reachable node %entry
	discovered a new reachable node %entry

Features:
CPU:generic

MergeICmpsLegacyPass: test
	discovered a new reachable node %entry
---- Branch Probability Info : test ----

		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
	discovered a new reachable node nullptr
	discovered a new reachable node %entry
Computing probabilities for entry

block-frequency: test
=====================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: test
 - entry: float = 1.0, int = 8

********** Begin Constant Hoisting **********
********** Function: test
********** End Constant Hoisting **********
	discovered a new reachable node %entry
---- Branch Probability Info : test ----

		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
	discovered a new reachable node nullptr
	discovered a new reachable node %entry
Computing probabilities for entry

block-frequency: test
=====================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: test
 - entry: float = 1.0, int = 8

	discovered a new reachable node %entry
	discovered a new reachable node %entry
	discovered a new reachable node %for.body.preheader
	discovered a new reachable node %for.cond.cleanup
	discovered a new reachable node %entry
	discovered a new reachable node %for.body.preheader
	discovered a new reachable node %for.cond.cleanup
MergeICmpsLegacyPass: acc
	discovered a new reachable node %entry
	discovered a new reachable node %for.body.preheader
	discovered a new reachable node %for.cond.cleanup
---- Branch Probability Info : acc ----

		Looking for trivial roots
Found a new trivial root: %for.cond.cleanup
Last visited node: %for.body.preheader
		Looking for non-trivial roots
Total: 3, Num: 4
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %for.cond.cleanup
3: %entry
4: %for.body.preheader
Found roots: %for.cond.cleanup 
	discovered a new reachable node nullptr
	discovered a new reachable node %for.cond.cleanup
	discovered a new reachable node %entry
	discovered a new reachable node %for.body.preheader
Computing probabilities for for.cond.cleanup
Computing probabilities for for.body.preheader
Computing probabilities for entry
set edge entry -> 0 successor probability to 0x50000000 / 0x80000000 = 62.50%
set edge entry -> 1 successor probability to 0x30000000 / 0x80000000 = 37.50%

block-frequency: acc
====================
reverse-post-order-traversal
 - 0: entry
 - 1: for.body.preheader
 - 2: for.cond.cleanup
loop-detection
compute-mass-in-function
 - node: entry
  => [ local  ] weight = 1342177280, succ = for.body.preheader
  => [ local  ] weight = 805306368, succ = for.cond.cleanup
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to for.body.preheader
  => assign 6000000000000000 (0000000000000000) to for.cond.cleanup
 - node: for.body.preheader
  => [ local  ] weight = 2147483648, succ = for.cond.cleanup
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to for.cond.cleanup
 - node: for.cond.cleanup
  => mass:  ffffffffffffffff
float-to-int: min = 0.625, max = 1.0, factor = 12.8
 - entry: float = 1.0, scaled = 12.8, int = 12
 - for.body.preheader: float = 0.625, scaled = 8.0, int = 8
 - for.cond.cleanup: float = 1.0, scaled = 12.8, int = 12
block-frequency-info: acc
 - entry: float = 1.0, int = 12
 - for.body.preheader: float = 0.625, int = 8
 - for.cond.cleanup: float = 1.0, int = 12

********** Begin Constant Hoisting **********
********** Function: acc
********** End Constant Hoisting **********
	discovered a new reachable node %entry
	discovered a new reachable node %for.body.preheader
	discovered a new reachable node %for.cond.cleanup
---- Branch Probability Info : acc ----

		Looking for trivial roots
Found a new trivial root: %for.cond.cleanup
Last visited node: %for.body.preheader
		Looking for non-trivial roots
Total: 3, Num: 4
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %for.cond.cleanup
3: %entry
4: %for.body.preheader
Found roots: %for.cond.cleanup 
	discovered a new reachable node nullptr
	discovered a new reachable node %for.cond.cleanup
	discovered a new reachable node %entry
	discovered a new reachable node %for.body.preheader
Computing probabilities for for.cond.cleanup
Computing probabilities for for.body.preheader
Computing probabilities for entry
set edge entry -> 0 successor probability to 0x50000000 / 0x80000000 = 62.50%
set edge entry -> 1 successor probability to 0x30000000 / 0x80000000 = 37.50%

block-frequency: acc
====================
reverse-post-order-traversal
 - 0: entry
 - 1: for.body.preheader
 - 2: for.cond.cleanup
loop-detection
compute-mass-in-function
 - node: entry
  => [ local  ] weight = 1342177280, succ = for.body.preheader
  => [ local  ] weight = 805306368, succ = for.cond.cleanup
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to for.body.preheader
  => assign 6000000000000000 (0000000000000000) to for.cond.cleanup
 - node: for.body.preheader
  => [ local  ] weight = 2147483648, succ = for.cond.cleanup
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to for.cond.cleanup
 - node: for.cond.cleanup
  => mass:  ffffffffffffffff
float-to-int: min = 0.625, max = 1.0, factor = 12.8
 - entry: float = 1.0, scaled = 12.8, int = 12
 - for.body.preheader: float = 0.625, scaled = 8.0, int = 8
 - for.cond.cleanup: float = 1.0, scaled = 12.8, int = 12
block-frequency-info: acc
 - entry: float = 1.0, int = 12
 - for.body.preheader: float = 0.625, int = 8
 - for.cond.cleanup: float = 1.0, int = 12

	discovered a new reachable node %entry
	discovered a new reachable node %for.body.preheader
	discovered a new reachable node %for.cond.cleanup
	discovered a new reachable node %entry
[SafeStack] Function: test
[SafeStack]     safestack is not requested for this function
	discovered a new reachable node %entry
	discovered a new reachable node %entry
---- Branch Probability Info : test ----

		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
	discovered a new reachable node nullptr
	discovered a new reachable node %entry
Computing probabilities for entry



=== test
Creating new node: t2: i32,ch = CopyFromReg t0, Register:i32 %0
Creating new node: t4: i32,ch = CopyFromReg t0, Register:i32 %1
Creating new node: t5: i32 = add nsw t4, t2
Creating new node: t7: ch,glue = CopyToReg t0, Register:i32 $r10, t5
Creating new node: t8: ch = DLXISD::Ret t7, Register:i32 $r10, t7:1
Initial selection DAG: %bb.0 'test:entry'
SelectionDAG has 9 nodes:
  t0: ch = EntryToken
      t4: i32,ch = CopyFromReg t0, Register:i32 %1
      t2: i32,ch = CopyFromReg t0, Register:i32 %0
    t5: i32 = add nsw t4, t2
  t7: ch,glue = CopyToReg t0, Register:i32 $r10, t5
  t8: ch = DLXISD::Ret t7, Register:i32 $r10, t7:1



Combining: t8: ch = DLXISD::Ret t7, Register:i32 $r10, t7:1

Combining: t7: ch,glue = CopyToReg t0, Register:i32 $r10, t5

Combining: t6: i32 = Register $r10

Combining: t5: i32 = add nsw t4, t2

Combining: t4: i32,ch = CopyFromReg t0, Register:i32 %1

Combining: t3: i32 = Register %1

Combining: t2: i32,ch = CopyFromReg t0, Register:i32 %0

Combining: t1: i32 = Register %0

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.0 'test:entry'
SelectionDAG has 9 nodes:
  t0: ch = EntryToken
      t4: i32,ch = CopyFromReg t0, Register:i32 %1
      t2: i32,ch = CopyFromReg t0, Register:i32 %0
    t5: i32 = add nsw t4, t2
  t7: ch,glue = CopyToReg t0, Register:i32 $r10, t5
  t8: ch = DLXISD::Ret t7, Register:i32 $r10, t7:1


Legalizing node: t6: i32 = Register $r10
Ignoring node results
Legally typed node: t6: i32 = Register $r10

Legalizing node: t3: i32 = Register %1
Ignoring node results
Legally typed node: t3: i32 = Register %1

Legalizing node: t1: i32 = Register %0
Ignoring node results
Legally typed node: t1: i32 = Register %0

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t2: i32,ch = CopyFromReg t0, Register:i32 %0
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t2: i32,ch = CopyFromReg t0, Register:i32 %0

Legalizing node: t4: i32,ch = CopyFromReg t0, Register:i32 %1
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t4: i32,ch = CopyFromReg t0, Register:i32 %1

Legalizing node: t5: i32 = add nsw t4, t2
Analyzing result type: i32
Legal result type
Analyzing operand: t4: i32,ch = CopyFromReg t0, Register:i32 %1
Legal operand
Analyzing operand: t2: i32,ch = CopyFromReg t0, Register:i32 %0
Legal operand
Legally typed node: t5: i32 = add nsw t4, t2

Legalizing node: t7: ch,glue = CopyToReg t0, Register:i32 $r10, t5
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t5: i32 = add nsw t4, t2
Legal operand
Legally typed node: t7: ch,glue = CopyToReg t0, Register:i32 $r10, t5

Legalizing node: t8: ch = DLXISD::Ret t7, Register:i32 $r10, t7:1
Analyzing result type: ch
Legal result type
Analyzing operand: t7: ch,glue = CopyToReg t0, Register:i32 $r10, t5
Legal operand
Analyzing operand: t7: ch,glue = CopyToReg t0, Register:i32 $r10, t5
Legal operand
Legally typed node: t8: ch = DLXISD::Ret t7, Register:i32 $r10, t7:1

Legalizing node: t65535: ch = handlenode t8
Analyzing result type: ch
Legal result type
Analyzing operand: t8: ch = DLXISD::Ret t7, Register:i32 $r10, t7:1
Legal operand
Legally typed node: t65535: ch = handlenode t8

Type-legalized selection DAG: %bb.0 'test:entry'
SelectionDAG has 9 nodes:
  t0: ch = EntryToken
      t4: i32,ch = CopyFromReg t0, Register:i32 %1
      t2: i32,ch = CopyFromReg t0, Register:i32 %0
    t5: i32 = add nsw t4, t2
  t7: ch,glue = CopyToReg t0, Register:i32 $r10, t5
  t8: ch = DLXISD::Ret t7, Register:i32 $r10, t7:1



Legalizing: t8: ch = DLXISD::Ret t7, Register:i32 $r10, t7:1
Legal node: nothing to do

Legalizing: t7: ch,glue = CopyToReg t0, Register:i32 $r10, t5
Legal node: nothing to do

Legalizing: t5: i32 = add nsw t4, t2
Legal node: nothing to do

Legalizing: t4: i32,ch = CopyFromReg t0, Register:i32 %1
Legal node: nothing to do

Legalizing: t2: i32,ch = CopyFromReg t0, Register:i32 %0
Legal node: nothing to do

Legalizing: t6: i32 = Register $r10

Legalizing: t3: i32 = Register %1

Legalizing: t1: i32 = Register %0

Legalizing: t0: ch = EntryToken
Legal node: nothing to do
Legalized selection DAG: %bb.0 'test:entry'
SelectionDAG has 9 nodes:
  t0: ch = EntryToken
      t4: i32,ch = CopyFromReg t0, Register:i32 %1
      t2: i32,ch = CopyFromReg t0, Register:i32 %0
    t5: i32 = add nsw t4, t2
  t7: ch,glue = CopyToReg t0, Register:i32 $r10, t5
  t8: ch = DLXISD::Ret t7, Register:i32 $r10, t7:1



Legalizing: t8: ch = DLXISD::Ret t7, Register:i32 $r10, t7:1
Legal node: nothing to do

Combining: t8: ch = DLXISD::Ret t7, Register:i32 $r10, t7:1

Legalizing: t7: ch,glue = CopyToReg t0, Register:i32 $r10, t5
Legal node: nothing to do

Combining: t7: ch,glue = CopyToReg t0, Register:i32 $r10, t5

Legalizing: t5: i32 = add nsw t4, t2
Legal node: nothing to do

Combining: t5: i32 = add nsw t4, t2

Legalizing: t4: i32,ch = CopyFromReg t0, Register:i32 %1
Legal node: nothing to do

Combining: t4: i32,ch = CopyFromReg t0, Register:i32 %1

Legalizing: t2: i32,ch = CopyFromReg t0, Register:i32 %0
Legal node: nothing to do

Combining: t2: i32,ch = CopyFromReg t0, Register:i32 %0

Legalizing: t6: i32 = Register $r10

Combining: t6: i32 = Register $r10

Legalizing: t3: i32 = Register %1

Combining: t3: i32 = Register %1

Legalizing: t1: i32 = Register %0

Combining: t1: i32 = Register %0

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.0 'test:entry'
SelectionDAG has 9 nodes:
  t0: ch = EntryToken
      t4: i32,ch = CopyFromReg t0, Register:i32 %1
      t2: i32,ch = CopyFromReg t0, Register:i32 %0
    t5: i32 = add nsw t4, t2
  t7: ch,glue = CopyToReg t0, Register:i32 $r10, t5
  t8: ch = DLXISD::Ret t7, Register:i32 $r10, t7:1


===== Instruction selection begins: %bb.0 'entry'

ISEL: Starting selection on root node: t8: ch = DLXISD::Ret t7, Register:i32 $r10, t7:1
ISEL: Starting pattern match
  Morphed node: t8: ch = PseudoRET Register:i32 $r10, t7, t7:1
ISEL: Match complete!

ISEL: Starting selection on root node: t7: ch,glue = CopyToReg t0, Register:i32 $r10, t5

ISEL: Starting selection on root node: t5: i32 = add nsw t4, t2
ISEL: Starting pattern match
  Initial Opcode index to 521
  Match failed at index 526
  Continuing at 559
  Morphed node: t5: i32 = ADD nsw t4, t2
ISEL: Match complete!

ISEL: Starting selection on root node: t4: i32,ch = CopyFromReg t0, Register:i32 %1

ISEL: Starting selection on root node: t2: i32,ch = CopyFromReg t0, Register:i32 %0

ISEL: Starting selection on root node: t6: i32 = Register $r10

ISEL: Starting selection on root node: t3: i32 = Register %1

ISEL: Starting selection on root node: t1: i32 = Register %0

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.0 'test:entry'
SelectionDAG has 9 nodes:
  t0: ch = EntryToken
      t4: i32,ch = CopyFromReg t0, Register:i32 %1
      t2: i32,ch = CopyFromReg t0, Register:i32 %0
    t5: i32 = ADD nsw t4, t2
  t7: ch,glue = CopyToReg t0, Register:i32 $r10, t5
  t8: ch = PseudoRET Register:i32 $r10, t7, t7:1


********** List Scheduling %bb.0 'entry' **********
SU(0): t8: ch = PseudoRET Register:i32 $r10, t7, t7:1

    t7: ch,glue = CopyToReg t0, Register:i32 $r10, t5

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 0
  Predecessors:
    SU(1): Data Latency=1
SU(1): t5: i32 = ADD nsw t4, t2

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 1
  Predecessors:
    SU(3): Data Latency=1
    SU(2): Data Latency=1
  Successors:
    SU(0): Data Latency=1
SU(2): t2: i32,ch = CopyFromReg t0, Register:i32 %0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(1): Data Latency=1
SU(3): t4: i32,ch = CopyFromReg t0, Register:i32 %1

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(1): Data Latency=1

Examining Available:
Height 0: SU(0): t8: ch = PseudoRET Register:i32 $r10, t7, t7:1

    t7: ch,glue = CopyToReg t0, Register:i32 $r10, t5


*** Scheduling [0]: SU(0): t8: ch = PseudoRET Register:i32 $r10, t7, t7:1

    t7: ch,glue = CopyToReg t0, Register:i32 $r10, t5


Examining Available:
Height 1: SU(1): t5: i32 = ADD nsw t4, t2


*** Scheduling [1]: SU(1): t5: i32 = ADD nsw t4, t2


Examining Available:
Height 2: SU(3): t4: i32,ch = CopyFromReg t0, Register:i32 %1

Height 2: SU(2): t2: i32,ch = CopyFromReg t0, Register:i32 %0


*** Scheduling [2]: SU(3): t4: i32,ch = CopyFromReg t0, Register:i32 %1


Examining Available:
Height 2: SU(2): t2: i32,ch = CopyFromReg t0, Register:i32 %0


*** Scheduling [3]: SU(2): t2: i32,ch = CopyFromReg t0, Register:i32 %0

*** Final schedule ***
SU(2): t2: i32,ch = CopyFromReg t0, Register:i32 %0

SU(3): t4: i32,ch = CopyFromReg t0, Register:i32 %1

SU(1): t5: i32 = ADD nsw t4, t2

SU(0): t8: ch = PseudoRET Register:i32 $r10, t7, t7:1

    t7: ch,glue = CopyToReg t0, Register:i32 $r10, t5


Total amount of phi nodes to update: 0
*** MachineFunction at end of ISel ***
# Machine code for function test: IsSSA, TracksLiveness
Function Live Ins: $r10 in %0, $r11 in %1

bb.0.entry:
  liveins: $r10, $r11
  %1:gpr = COPY $r11
  %0:gpr = COPY $r10
  %2:gpr = nsw ADD %1:gpr, %0:gpr
  $r10 = COPY %2:gpr
  PseudoRET implicit $r10

# End machine code for function test.

# Machine code for function test: IsSSA, TracksLiveness
Function Live Ins: $r10 in %0, $r11 in %1

0B	bb.0.entry:
	  liveins: $r10, $r11
16B	  %1:gpr = COPY $r11
32B	  %0:gpr = COPY $r10
48B	  %2:gpr = nsw ADD %1:gpr, %0:gpr
64B	  $r10 = COPY %2:gpr
80B	  PseudoRET implicit $r10

# End machine code for function test.

********** Stack Coloring **********
********** Function: test
	discovered a new reachable node %bb.0
******** Pre-regalloc Machine LICM: test ********
	discovered a new reachable node %bb.0

block-frequency: test
=====================
reverse-post-order-traversal
 - 0: BB0[entry]
loop-detection
compute-mass-in-function
 - node: BB0[entry]
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - BB0[entry]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: test
 - BB0[entry]: float = 1.0, int = 8

Entering: entry
Exiting: entry
		Looking for trivial roots
Found a new trivial root: %bb.0
Last visited node: %bb.0
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.0
Found roots: %bb.0 
	discovered a new reachable node nullptr
	discovered a new reachable node %bb.0
******** Machine Sinking ********
********** PEEPHOLE OPTIMIZER **********
********** Function: test
Skipping Detect dead lanes pass
********** PROCESS IMPLICIT DEFS **********
********** Function: test
********** REWRITING TWO-ADDR INSTRS **********
********** Function: test
	discovered a new reachable node %bb.0
# Machine code for function test: NoPHIs, TracksLiveness
Function Live Ins: $r10 in %0, $r11 in %1

0B	bb.0.entry:
	  liveins: $r10, $r11
16B	  %1:gpr = COPY killed $r11
32B	  %0:gpr = COPY killed $r10
48B	  %2:gpr = nsw ADD killed %1:gpr, killed %0:gpr
64B	  $r10 = COPY killed %2:gpr
80B	  PseudoRET implicit killed $r10

# End machine code for function test.

Computing live-in reg-units in ABI blocks.
0B	%bb.0 R10#0 R11#0
Created 2 new intervals.
********** INTERVALS **********
R10 [0B,32r:0)[64r,80r:1)  0@0B-phi 1@64r
R11 [0B,16r:0)  0@0B-phi
%0 [32r,48r:0)  0@32r weight:0.000000e+00
%1 [16r,48r:0)  0@16r weight:0.000000e+00
%2 [48r,64r:0)  0@48r weight:0.000000e+00
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function test: NoPHIs, TracksLiveness
Function Live Ins: $r10 in %0, $r11 in %1

0B	bb.0.entry:
	  liveins: $r10, $r11
16B	  %1:gpr = COPY $r11
32B	  %0:gpr = COPY $r10
48B	  %2:gpr = nsw ADD %1:gpr, %0:gpr
64B	  $r10 = COPY %2:gpr
80B	  PseudoRET implicit $r10

# End machine code for function test.

********** SIMPLE REGISTER COALESCING **********
********** Function: test
********** JOINING INTERVALS ***********
entry:
16B	%1:gpr = COPY $r11
	Considering merging %1 with $r11
	Can only merge into reserved registers.
32B	%0:gpr = COPY $r10
	Considering merging %0 with $r10
	Can only merge into reserved registers.
64B	$r10 = COPY %2:gpr
	Considering merging %2 with $r10
	Can only merge into reserved registers.
Trying to inflate 0 regs.
********** INTERVALS **********
R10 [0B,32r:0)[64r,80r:1)  0@0B-phi 1@64r
R11 [0B,16r:0)  0@0B-phi
%0 [32r,48r:0)  0@32r weight:0.000000e+00
%1 [16r,48r:0)  0@16r weight:0.000000e+00
%2 [48r,64r:0)  0@48r weight:0.000000e+00
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function test: NoPHIs, TracksLiveness
Function Live Ins: $r10 in %0, $r11 in %1

0B	bb.0.entry:
	  liveins: $r10, $r11
16B	  %1:gpr = COPY $r11
32B	  %0:gpr = COPY $r10
48B	  %2:gpr = nsw ADD %1:gpr, %0:gpr
64B	  $r10 = COPY %2:gpr
80B	  PseudoRET implicit $r10

# End machine code for function test.


block-frequency: test
=====================
reverse-post-order-traversal
 - 0: BB0[entry]
loop-detection
compute-mass-in-function
 - node: BB0[entry]
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - BB0[entry]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: test
 - BB0[entry]: float = 1.0, int = 8

********** GREEDY REGISTER ALLOCATION **********
********** Function: test
********** Compute Spill Weights **********
********** Function: test
********** INTERVALS **********
R10 [0B,32r:0)[64r,80r:1)  0@0B-phi 1@64r
R11 [0B,16r:0)  0@0B-phi
%0 [32r,48r:0)  0@32r weight:INF
%1 [16r,48r:0)  0@16r weight:4.675926e-03
%2 [48r,64r:0)  0@48r weight:INF
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function test: NoPHIs, TracksLiveness
Function Live Ins: $r10 in %0, $r11 in %1

0B	bb.0.entry:
	  liveins: $r10, $r11
16B	  %1:gpr = COPY $r11
32B	  %0:gpr = COPY $r10
48B	  %2:gpr = nsw ADD %1:gpr, %0:gpr
64B	  $r10 = COPY %2:gpr
80B	  PseudoRET implicit $r10

# End machine code for function test.


selectOrSplit GPR:%1 [16r,48r:0)  0@16r weight:4.675926e-03 w=4.675926e-03
AllocationOrder(GPR) = [ $r10 $r11 $r12 $r13 $r14 $r15 $r16 $r17 $r5 $r6 $r7 $r28 $r29 $r30 $r31 $r8 $r9 $r18 $r19 $r20 $r21 $r22 $r23 $r24 $r25 $r26 $r27 $r1 ]
hints: $r11
assigning %1 to $r11: R11 [16r,48r:0)  0@16r

selectOrSplit GPR:%0 [32r,48r:0)  0@32r weight:INF w=INF
hints: $r10
assigning %0 to $r10: R10 [32r,48r:0)  0@32r

selectOrSplit GPR:%2 [48r,64r:0)  0@48r weight:INF w=INF
hints: $r10
assigning %2 to $r10: R10 [48r,64r:0)  0@48r
********** REWRITE VIRTUAL REGISTERS **********
********** Function: test
********** REGISTER MAP **********
[%0 -> $r10] GPR
[%1 -> $r11] GPR
[%2 -> $r10] GPR

0B	bb.0.entry:
	  liveins: $r10, $r11
16B	  %1:gpr = COPY $r11
32B	  %0:gpr = COPY $r10
48B	  %2:gpr = nsw ADD killed %1:gpr, killed %0:gpr
64B	  $r10 = COPY killed %2:gpr
80B	  PseudoRET implicit $r10
> $r11 = COPY $r11
Identity copy: $r11 = COPY $r11
  deleted.
> $r10 = COPY $r10
Identity copy: $r10 = COPY $r10
  deleted.
> $r10 = nsw ADD killed $r11, killed $r10
> $r10 = COPY killed $r10
Identity copy: $r10 = COPY killed $r10
  deleted.
> PseudoRET implicit $r10
********** Stack Slot Coloring **********
********** Function: test
MCP: BackwardCopyPropagateBlock entry
MCP: ForwardCopyPropagateBlock entry
******** Post-regalloc Machine LICM: test ********

block-frequency: test
=====================
reverse-post-order-traversal
 - 0: BB0[entry]
loop-detection
compute-mass-in-function
 - node: BB0[entry]
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - BB0[entry]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: test
 - BB0[entry]: float = 1.0, int = 8

	discovered a new reachable node %bb.0
		Looking for trivial roots
Found a new trivial root: %bb.0
Last visited node: %bb.0
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.0
Found roots: %bb.0 
	discovered a new reachable node nullptr
	discovered a new reachable node %bb.0
alloc FI(0) at SP[-4]
MCP: BackwardCopyPropagateBlock entry
MCP: ForwardCopyPropagateBlock entry
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: test
	discovered a new reachable node %bb.0

block-frequency: test
=====================
reverse-post-order-traversal
 - 0: BB0[entry]
loop-detection
compute-mass-in-function
 - node: BB0[entry]
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - BB0[entry]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: test
 - BB0[entry]: float = 1.0, int = 8

		Looking for trivial roots
Found a new trivial root: %bb.0
Last visited node: %bb.0
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.0
Found roots: %bb.0 
	discovered a new reachable node nullptr
	discovered a new reachable node %bb.0
********** COMPUTING STACKMAP LIVENESS: test **********
	discovered a new reachable node %bb.0
	discovered a new reachable node %entry
	discovered a new reachable node %for.body.preheader
	discovered a new reachable node %for.cond.cleanup
[SafeStack] Function: acc
[SafeStack]     safestack is not requested for this function
	discovered a new reachable node %entry
	discovered a new reachable node %for.body.preheader
	discovered a new reachable node %for.cond.cleanup
	discovered a new reachable node %entry
	discovered a new reachable node %for.body.preheader
	discovered a new reachable node %for.cond.cleanup
---- Branch Probability Info : acc ----

		Looking for trivial roots
Found a new trivial root: %for.cond.cleanup
Last visited node: %for.body.preheader
		Looking for non-trivial roots
Total: 3, Num: 4
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %for.cond.cleanup
3: %entry
4: %for.body.preheader
Found roots: %for.cond.cleanup 
	discovered a new reachable node nullptr
	discovered a new reachable node %for.cond.cleanup
	discovered a new reachable node %entry
	discovered a new reachable node %for.body.preheader
Computing probabilities for for.cond.cleanup
Computing probabilities for for.body.preheader
Computing probabilities for entry
set edge entry -> 0 successor probability to 0x50000000 / 0x80000000 = 62.50%
set edge entry -> 1 successor probability to 0x30000000 / 0x80000000 = 37.50%



=== acc
Creating new node: t2: i32,ch = CopyFromReg t0, Register:i32 %2
Creating constant: t3: i32 = Constant<0>
Creating new node: t5: i1 = setcc t2, Constant:i32<0>, setgt:ch
Creating new node: t7: ch = CopyToReg t0, Register:i32 %3, Constant:i32<0>
Creating constant: t8: i1 = Constant<-1>
Creating new node: t9: i1 = xor t5, Constant:i1<-1>
Creating new node: t11: ch = brcond t7, t9, BasicBlock:ch<for.cond.cleanup 0x69a19f0>
Creating new node: t13: ch = br t11, BasicBlock:ch<for.body.preheader 0x69a1930>
Initial selection DAG: %bb.0 'acc:entry'
SelectionDAG has 14 nodes:
  t0: ch = EntryToken
      t7: ch = CopyToReg t0, Register:i32 %3, Constant:i32<0>
          t2: i32,ch = CopyFromReg t0, Register:i32 %2
        t5: i1 = setcc t2, Constant:i32<0>, setgt:ch
      t9: i1 = xor t5, Constant:i1<-1>
    t11: ch = brcond t7, t9, BasicBlock:ch<for.cond.cleanup 0x69a19f0>
  t13: ch = br t11, BasicBlock:ch<for.body.preheader 0x69a1930>



Combining: t13: ch = br t11, BasicBlock:ch<for.body.preheader 0x69a1930>

Combining: t12: ch = BasicBlock<for.body.preheader 0x69a1930>

Combining: t11: ch = brcond t7, t9, BasicBlock:ch<for.cond.cleanup 0x69a19f0>
Creating new node: t15: i1 = setcc t2, Constant:i32<0>, setle:ch
Creating new node: t16: ch = brcond t7, t15, BasicBlock:ch<for.cond.cleanup 0x69a19f0>
 ... into: t16: ch = brcond t7, t15, BasicBlock:ch<for.cond.cleanup 0x69a19f0>

Combining: t13: ch = br t16, BasicBlock:ch<for.body.preheader 0x69a1930>

Combining: t16: ch = brcond t7, t15, BasicBlock:ch<for.cond.cleanup 0x69a19f0>

Combining: t15: i1 = setcc t2, Constant:i32<0>, setle:ch
Creating constant: t17: i32 = Constant<1>
Creating new node: t19: i1 = setcc t2, Constant:i32<1>, setlt:ch
 ... into: t19: i1 = setcc t2, Constant:i32<1>, setlt:ch

Combining: t16: ch = brcond t7, t19, BasicBlock:ch<for.cond.cleanup 0x69a19f0>

Combining: t19: i1 = setcc t2, Constant:i32<1>, setlt:ch

Combining: t18: ch = setlt

Combining: t17: i32 = Constant<1>

Combining: t10: ch = BasicBlock<for.cond.cleanup 0x69a19f0>

Combining: t7: ch = CopyToReg t0, Register:i32 %3, Constant:i32<0>

Combining: t6: i32 = Register %3

Combining: t3: i32 = Constant<0>

Combining: t2: i32,ch = CopyFromReg t0, Register:i32 %2

Combining: t1: i32 = Register %2

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.0 'acc:entry'
SelectionDAG has 13 nodes:
  t0: ch = EntryToken
      t7: ch = CopyToReg t0, Register:i32 %3, Constant:i32<0>
        t2: i32,ch = CopyFromReg t0, Register:i32 %2
      t19: i1 = setcc t2, Constant:i32<1>, setlt:ch
    t16: ch = brcond t7, t19, BasicBlock:ch<for.cond.cleanup 0x69a19f0>
  t13: ch = br t16, BasicBlock:ch<for.body.preheader 0x69a1930>


Legalizing node: t18: ch = setlt
Analyzing result type: ch
Legal result type
Legally typed node: t18: ch = setlt

Legalizing node: t17: i32 = Constant<1>
Analyzing result type: i32
Legal result type
Legally typed node: t17: i32 = Constant<1>

Legalizing node: t12: ch = BasicBlock<for.body.preheader 0x69a1930>
Analyzing result type: ch
Legal result type
Legally typed node: t12: ch = BasicBlock<for.body.preheader 0x69a1930>

Legalizing node: t10: ch = BasicBlock<for.cond.cleanup 0x69a19f0>
Analyzing result type: ch
Legal result type
Legally typed node: t10: ch = BasicBlock<for.cond.cleanup 0x69a19f0>

Legalizing node: t6: i32 = Register %3
Ignoring node results
Legally typed node: t6: i32 = Register %3

Legalizing node: t3: i32 = Constant<0>
Analyzing result type: i32
Legal result type
Legally typed node: t3: i32 = Constant<0>

Legalizing node: t1: i32 = Register %2
Ignoring node results
Legally typed node: t1: i32 = Register %2

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t2: i32,ch = CopyFromReg t0, Register:i32 %2
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t2: i32,ch = CopyFromReg t0, Register:i32 %2

Legalizing node: t19: i1 = setcc t2, Constant:i32<1>, setlt:ch
Analyzing result type: i1
Promote integer result: t19: i1 = setcc t2, Constant:i32<1>, setlt:ch

Creating new node: t20: i32 = setcc t2, Constant:i32<1>, setlt:ch
Legalizing node: t20: i32 = setcc t2, Constant:i32<1>, setlt:ch
Analyzing result type: i32
Legal result type
Analyzing operand: t2: i32,ch = CopyFromReg t0, Register:i32 %2
Legal operand
Analyzing operand: t17: i32 = Constant<1>
Legal operand
Analyzing operand: t18: ch = setlt
Legal operand
Legally typed node: t20: i32 = setcc t2, Constant:i32<1>, setlt:ch

Legalizing node: t7: ch = CopyToReg t0, Register:i32 %3, Constant:i32<0>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t3: i32 = Constant<0>
Legal operand
Legally typed node: t7: ch = CopyToReg t0, Register:i32 %3, Constant:i32<0>

Legalizing node: t16: ch = brcond t7, t19, BasicBlock:ch<for.cond.cleanup 0x69a19f0>
Analyzing result type: ch
Legal result type
Analyzing operand: t7: ch = CopyToReg t0, Register:i32 %3, Constant:i32<0>
Legal operand
Analyzing operand: t19: i1 = setcc t2, Constant:i32<1>, setlt:ch
Promote integer operand: t16: ch = brcond t7, t19, BasicBlock:ch<for.cond.cleanup 0x69a19f0>

Creating new node: t21: i32 = zero_extend t19
Legalizing node: t21: i32 = zero_extend t19
Analyzing result type: i32
Legal result type
Analyzing operand: t19: i1 = setcc t2, Constant:i32<1>, setlt:ch
Promote integer operand: t21: i32 = zero_extend t19

Creating new node: t22: i32 = and t20, Constant:i32<1>
Replacing: t21: i32 = zero_extend t19
     with: t22: i32 = and t20, Constant:i32<1>
Legalizing node: t22: i32 = and t20, Constant:i32<1>
Analyzing result type: i32
Legal result type
Analyzing operand: t20: i32 = setcc t2, Constant:i32<1>, setlt:ch
Legal operand
Analyzing operand: t17: i32 = Constant<1>
Legal operand
Legally typed node: t22: i32 = and t20, Constant:i32<1>

Legalizing node: t16: ch = brcond t7, t22, BasicBlock:ch<for.cond.cleanup 0x69a19f0>
Analyzing result type: ch
Legal result type
Analyzing operand: t7: ch = CopyToReg t0, Register:i32 %3, Constant:i32<0>
Legal operand
Analyzing operand: t22: i32 = and t20, Constant:i32<1>
Legal operand
Analyzing operand: t10: ch = BasicBlock<for.cond.cleanup 0x69a19f0>
Legal operand
Legally typed node: t16: ch = brcond t7, t22, BasicBlock:ch<for.cond.cleanup 0x69a19f0>

Legalizing node: t13: ch = br t16, BasicBlock:ch<for.body.preheader 0x69a1930>
Analyzing result type: ch
Legal result type
Analyzing operand: t16: ch = brcond t7, t22, BasicBlock:ch<for.cond.cleanup 0x69a19f0>
Legal operand
Analyzing operand: t12: ch = BasicBlock<for.body.preheader 0x69a1930>
Legal operand
Legally typed node: t13: ch = br t16, BasicBlock:ch<for.body.preheader 0x69a1930>

Legalizing node: t65535: ch = handlenode t13
Analyzing result type: ch
Legal result type
Analyzing operand: t13: ch = br t16, BasicBlock:ch<for.body.preheader 0x69a1930>
Legal operand
Legally typed node: t65535: ch = handlenode t13

Type-legalized selection DAG: %bb.0 'acc:entry'
SelectionDAG has 14 nodes:
  t0: ch = EntryToken
      t7: ch = CopyToReg t0, Register:i32 %3, Constant:i32<0>
          t2: i32,ch = CopyFromReg t0, Register:i32 %2
        t20: i32 = setcc t2, Constant:i32<1>, setlt:ch
      t22: i32 = and t20, Constant:i32<1>
    t16: ch = brcond t7, t22, BasicBlock:ch<for.cond.cleanup 0x69a19f0>
  t13: ch = br t16, BasicBlock:ch<for.body.preheader 0x69a1930>



Combining: t22: i32 = and t20, Constant:i32<1>

Replacing.2 t22: i32 = and t20, Constant:i32<1>

With: t20: i32 = setcc t2, Constant:i32<1>, setlt:ch


Combining: t20: i32 = setcc t2, Constant:i32<1>, setlt:ch

Combining: t18: ch = setlt

Combining: t17: i32 = Constant<1>

Combining: t16: ch = brcond t7, t20, BasicBlock:ch<for.cond.cleanup 0x69a19f0>

Combining: t13: ch = br t16, BasicBlock:ch<for.body.preheader 0x69a1930>

Combining: t12: ch = BasicBlock<for.body.preheader 0x69a1930>

Combining: t10: ch = BasicBlock<for.cond.cleanup 0x69a19f0>

Combining: t7: ch = CopyToReg t0, Register:i32 %3, Constant:i32<0>

Combining: t6: i32 = Register %3

Combining: t3: i32 = Constant<0>

Combining: t2: i32,ch = CopyFromReg t0, Register:i32 %2

Combining: t1: i32 = Register %2

Combining: t0: ch = EntryToken
Optimized type-legalized selection DAG: %bb.0 'acc:entry'
SelectionDAG has 13 nodes:
  t0: ch = EntryToken
      t7: ch = CopyToReg t0, Register:i32 %3, Constant:i32<0>
        t2: i32,ch = CopyFromReg t0, Register:i32 %2
      t20: i32 = setcc t2, Constant:i32<1>, setlt:ch
    t16: ch = brcond t7, t20, BasicBlock:ch<for.cond.cleanup 0x69a19f0>
  t13: ch = br t16, BasicBlock:ch<for.body.preheader 0x69a1930>



Legalizing: t13: ch = br t16, BasicBlock:ch<for.body.preheader 0x69a1930>
Legal node: nothing to do

Legalizing: t16: ch = brcond t7, t20, BasicBlock:ch<for.cond.cleanup 0x69a19f0>
Legal node: nothing to do

Legalizing: t20: i32 = setcc t2, Constant:i32<1>, setlt:ch
Legal node: nothing to do

Legalizing: t7: ch = CopyToReg t0, Register:i32 %3, Constant:i32<0>
Legal node: nothing to do

Legalizing: t2: i32,ch = CopyFromReg t0, Register:i32 %2
Legal node: nothing to do

Legalizing: t18: ch = setlt
Legal node: nothing to do

Legalizing: t17: i32 = Constant<1>
Legal node: nothing to do

Legalizing: t12: ch = BasicBlock<for.body.preheader 0x69a1930>
Legal node: nothing to do

Legalizing: t10: ch = BasicBlock<for.cond.cleanup 0x69a19f0>
Legal node: nothing to do

Legalizing: t6: i32 = Register %3

Legalizing: t3: i32 = Constant<0>
Legal node: nothing to do

Legalizing: t1: i32 = Register %2

Legalizing: t0: ch = EntryToken
Legal node: nothing to do
Legalized selection DAG: %bb.0 'acc:entry'
SelectionDAG has 13 nodes:
  t0: ch = EntryToken
      t7: ch = CopyToReg t0, Register:i32 %3, Constant:i32<0>
        t2: i32,ch = CopyFromReg t0, Register:i32 %2
      t20: i32 = setcc t2, Constant:i32<1>, setlt:ch
    t16: ch = brcond t7, t20, BasicBlock:ch<for.cond.cleanup 0x69a19f0>
  t13: ch = br t16, BasicBlock:ch<for.body.preheader 0x69a1930>



Legalizing: t13: ch = br t16, BasicBlock:ch<for.body.preheader 0x69a1930>
Legal node: nothing to do

Combining: t13: ch = br t16, BasicBlock:ch<for.body.preheader 0x69a1930>

Legalizing: t16: ch = brcond t7, t20, BasicBlock:ch<for.cond.cleanup 0x69a19f0>
Legal node: nothing to do

Combining: t16: ch = brcond t7, t20, BasicBlock:ch<for.cond.cleanup 0x69a19f0>

Legalizing: t20: i32 = setcc t2, Constant:i32<1>, setlt:ch
Legal node: nothing to do

Combining: t20: i32 = setcc t2, Constant:i32<1>, setlt:ch

Legalizing: t7: ch = CopyToReg t0, Register:i32 %3, Constant:i32<0>
Legal node: nothing to do

Combining: t7: ch = CopyToReg t0, Register:i32 %3, Constant:i32<0>

Legalizing: t2: i32,ch = CopyFromReg t0, Register:i32 %2
Legal node: nothing to do

Combining: t2: i32,ch = CopyFromReg t0, Register:i32 %2

Legalizing: t18: ch = setlt
Legal node: nothing to do

Combining: t18: ch = setlt

Legalizing: t17: i32 = Constant<1>
Legal node: nothing to do

Combining: t17: i32 = Constant<1>

Legalizing: t12: ch = BasicBlock<for.body.preheader 0x69a1930>
Legal node: nothing to do

Combining: t12: ch = BasicBlock<for.body.preheader 0x69a1930>

Legalizing: t10: ch = BasicBlock<for.cond.cleanup 0x69a19f0>
Legal node: nothing to do

Combining: t10: ch = BasicBlock<for.cond.cleanup 0x69a19f0>

Legalizing: t6: i32 = Register %3

Combining: t6: i32 = Register %3

Legalizing: t3: i32 = Constant<0>
Legal node: nothing to do

Combining: t3: i32 = Constant<0>

Legalizing: t1: i32 = Register %2

Combining: t1: i32 = Register %2

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.0 'acc:entry'
SelectionDAG has 13 nodes:
  t0: ch = EntryToken
      t7: ch = CopyToReg t0, Register:i32 %3, Constant:i32<0>
        t2: i32,ch = CopyFromReg t0, Register:i32 %2
      t20: i32 = setcc t2, Constant:i32<1>, setlt:ch
    t16: ch = brcond t7, t20, BasicBlock:ch<for.cond.cleanup 0x69a19f0>
  t13: ch = br t16, BasicBlock:ch<for.body.preheader 0x69a1930>


===== Instruction selection begins: %bb.0 'entry'

ISEL: Starting selection on root node: t13: ch = br t16, BasicBlock:ch<for.body.preheader 0x69a1930>
ISEL: Starting pattern match
  Initial Opcode index to 1188
  Morphed node: t13: ch = PseudoBR BasicBlock:ch<for.body.preheader 0x69a1930>, t16
ISEL: Match complete!

ISEL: Starting selection on root node: t16: ch = brcond t7, t20, BasicBlock:ch<for.cond.cleanup 0x69a19f0>
ISEL: Starting pattern match
  Initial Opcode index to 183
  Skipped scope entry (due to false predicate) at index 194, continuing at 234
Creating new machine node: t23: i32 = SLT t2, Constant:i32<1>
  Created node: t23: i32 = SLT t2, Constant:i32<1>
  Morphed node: t16: ch = BNEZ t23, BasicBlock:ch<for.cond.cleanup 0x69a19f0>, t7
ISEL: Match complete!

ISEL: Starting selection on root node: t7: ch = CopyToReg t0, Register:i32 %3, Constant:i32<0>

ISEL: Starting selection on root node: t2: i32,ch = CopyFromReg t0, Register:i32 %2

ISEL: Starting selection on root node: t17: i32 = Constant<1>
ISEL: Starting pattern match
  Initial Opcode index to 1152
Creating constant: t24: i32 = TargetConstant<1>
Creating new machine node: t25: i32 = LHI TargetConstant:i32<1>
  Created node: t25: i32 = LHI TargetConstant:i32<1>
  Morphed node: t17: i32 = ADDI t25, TargetConstant:i32<1>
ISEL: Match complete!

ISEL: Starting selection on root node: t12: ch = BasicBlock<for.body.preheader 0x69a1930>

ISEL: Starting selection on root node: t10: ch = BasicBlock<for.cond.cleanup 0x69a19f0>

ISEL: Starting selection on root node: t6: i32 = Register %3

ISEL: Starting selection on root node: t3: i32 = Constant<0>
ISEL: Starting pattern match
  Initial Opcode index to 1152
Creating constant: t26: i32 = TargetConstant<0>
Creating new machine node: t27: i32 = LHI TargetConstant:i32<0>
  Created node: t27: i32 = LHI TargetConstant:i32<0>
  Morphed node: t3: i32 = ADDI t27, TargetConstant:i32<0>
ISEL: Match complete!

ISEL: Starting selection on root node: t1: i32 = Register %2

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.0 'acc:entry'
SelectionDAG has 16 nodes:
  t0: ch = EntryToken
        t2: i32,ch = CopyFromReg t0, Register:i32 %2
          t25: i32 = LHI TargetConstant:i32<1>
        t17: i32 = ADDI t25, TargetConstant:i32<1>
      t23: i32 = SLT t2, t17
          t27: i32 = LHI TargetConstant:i32<0>
        t3: i32 = ADDI t27, TargetConstant:i32<0>
      t7: ch = CopyToReg t0, Register:i32 %3, t3
    t16: ch = BNEZ t23, BasicBlock:ch<for.cond.cleanup 0x69a19f0>, t7
  t13: ch = PseudoBR BasicBlock:ch<for.body.preheader 0x69a1930>, t16


********** List Scheduling %bb.0 'entry' **********
SU(0): t13: ch = PseudoBR BasicBlock:ch<for.body.preheader 0x69a1930>, t16

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t16: ch = BNEZ t23, BasicBlock:ch<for.cond.cleanup 0x69a19f0>, t7

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 1
  Predecessors:
    SU(5): Data Latency=1
    SU(2): Ord  Latency=1 Barrier
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t7: ch = CopyToReg t0, Register:i32 %3, t3

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(1): Ord  Latency=1 Barrier
SU(3): t3: i32 = ADDI t27, TargetConstant:i32<0>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 3
  Predecessors:
    SU(4): Data Latency=1
  Successors:
    SU(2): Data Latency=1
SU(4): t27: i32 = LHI TargetConstant:i32<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(3): Data Latency=1
SU(5): t23: i32 = SLT t2, t17

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(8): Data Latency=1
    SU(6): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(6): t17: i32 = ADDI t25, TargetConstant:i32<1>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 3
  Predecessors:
    SU(7): Data Latency=1
  Successors:
    SU(5): Data Latency=1
SU(7): t25: i32 = LHI TargetConstant:i32<1>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 4
  Successors:
    SU(6): Data Latency=1
SU(8): t2: i32,ch = CopyFromReg t0, Register:i32 %2

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(5): Data Latency=1

Examining Available:
Height 0: SU(0): t13: ch = PseudoBR BasicBlock:ch<for.body.preheader 0x69a1930>, t16


*** Scheduling [0]: SU(0): t13: ch = PseudoBR BasicBlock:ch<for.body.preheader 0x69a1930>, t16


Examining Available:
Height 1: SU(1): t16: ch = BNEZ t23, BasicBlock:ch<for.cond.cleanup 0x69a19f0>, t7


*** Scheduling [1]: SU(1): t16: ch = BNEZ t23, BasicBlock:ch<for.cond.cleanup 0x69a19f0>, t7


Examining Available:
Height 2: SU(2): t7: ch = CopyToReg t0, Register:i32 %3, t3

Height 2: SU(5): t23: i32 = SLT t2, t17


*** Scheduling [2]: SU(2): t7: ch = CopyToReg t0, Register:i32 %3, t3


Examining Available:
Height 3: SU(3): t3: i32 = ADDI t27, TargetConstant:i32<0>

Height 2: SU(5): t23: i32 = SLT t2, t17


*** Scheduling [3]: SU(3): t3: i32 = ADDI t27, TargetConstant:i32<0>


Examining Available:
Height 4: SU(4): t27: i32 = LHI TargetConstant:i32<0>

Height 2: SU(5): t23: i32 = SLT t2, t17


*** Scheduling [4]: SU(4): t27: i32 = LHI TargetConstant:i32<0>


Examining Available:
Height 2: SU(5): t23: i32 = SLT t2, t17


*** Scheduling [5]: SU(5): t23: i32 = SLT t2, t17


Examining Available:
Height 6: SU(8): t2: i32,ch = CopyFromReg t0, Register:i32 %2

Height 6: SU(6): t17: i32 = ADDI t25, TargetConstant:i32<1>


*** Scheduling [6]: SU(8): t2: i32,ch = CopyFromReg t0, Register:i32 %2


Examining Available:
Height 6: SU(6): t17: i32 = ADDI t25, TargetConstant:i32<1>


*** Scheduling [7]: SU(6): t17: i32 = ADDI t25, TargetConstant:i32<1>


Examining Available:
Height 8: SU(7): t25: i32 = LHI TargetConstant:i32<1>


*** Scheduling [8]: SU(7): t25: i32 = LHI TargetConstant:i32<1>

*** Final schedule ***
SU(7): t25: i32 = LHI TargetConstant:i32<1>

SU(6): t17: i32 = ADDI t25, TargetConstant:i32<1>

SU(8): t2: i32,ch = CopyFromReg t0, Register:i32 %2

SU(5): t23: i32 = SLT t2, t17

SU(4): t27: i32 = LHI TargetConstant:i32<0>

SU(3): t3: i32 = ADDI t27, TargetConstant:i32<0>

SU(2): t7: ch = CopyToReg t0, Register:i32 %3, t3

SU(1): t16: ch = BNEZ t23, BasicBlock:ch<for.cond.cleanup 0x69a19f0>, t7

SU(0): t13: ch = PseudoBR BasicBlock:ch<for.body.preheader 0x69a1930>, t16


Total amount of phi nodes to update: 1
Node 0 : (0x69a1ab0, 2147483651)
Creating new node: t2: i32,ch = CopyFromReg t0, Register:i32 %2
Creating constant: t3: i32 = Constant<-1>
Creating new node: t4: i32 = add nsw t2, Constant:i32<-1>
Creating new node: t5: i33 = zero_extend t4
Creating constant: t6: i32 = Constant<-2>
Creating new node: t7: i32 = add nsw t2, Constant:i32<-2>
Creating new node: t8: i33 = zero_extend t7
Creating new node: t9: i33 = mul t5, t8
Creating constant: t10: i33 = Constant<1>
Creating constant: t11: i32 = Constant<1>
Creating new node: t12: i33 = srl t9, Constant:i32<1>
Creating new node: t13: i32 = truncate t12
Creating new node: t14: i32 = add t13, t2
Creating new node: t15: i32 = add t14, Constant:i32<-1>
Creating new node: t17: ch = CopyToReg t0, Register:i32 %0, t15
Initial selection DAG: %bb.1 'acc:for.body.preheader'
SelectionDAG has 18 nodes:
  t0: ch = EntryToken
  t2: i32,ch = CopyFromReg t0, Register:i32 %2
  t10: i33 = Constant<1>
                t4: i32 = add nsw t2, Constant:i32<-1>
              t5: i33 = zero_extend t4
                t7: i32 = add nsw t2, Constant:i32<-2>
              t8: i33 = zero_extend t7
            t9: i33 = mul t5, t8
          t12: i33 = srl t9, Constant:i32<1>
        t13: i32 = truncate t12
      t14: i32 = add t13, t2
    t15: i32 = add t14, Constant:i32<-1>
  t17: ch = CopyToReg t0, Register:i32 %0, t15



Combining: t17: ch = CopyToReg t0, Register:i32 %0, t15

Combining: t16: i32 = Register %0

Combining: t15: i32 = add t14, Constant:i32<-1>

Combining: t14: i32 = add t13, t2

Combining: t13: i32 = truncate t12

Combining: t12: i33 = srl t9, Constant:i32<1>

Combining: t11: i32 = Constant<1>

Combining: t9: i33 = mul t5, t8

Combining: t8: i33 = zero_extend t7

Combining: t7: i32 = add nsw t2, Constant:i32<-2>

Combining: t6: i32 = Constant<-2>

Combining: t5: i33 = zero_extend t4

Combining: t4: i32 = add nsw t2, Constant:i32<-1>

Combining: t3: i32 = Constant<-1>

Combining: t2: i32,ch = CopyFromReg t0, Register:i32 %2

Combining: t1: i32 = Register %2

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.1 'acc:for.body.preheader'
SelectionDAG has 17 nodes:
  t0: ch = EntryToken
  t2: i32,ch = CopyFromReg t0, Register:i32 %2
                t4: i32 = add nsw t2, Constant:i32<-1>
              t5: i33 = zero_extend t4
                t7: i32 = add nsw t2, Constant:i32<-2>
              t8: i33 = zero_extend t7
            t9: i33 = mul t5, t8
          t12: i33 = srl t9, Constant:i32<1>
        t13: i32 = truncate t12
      t14: i32 = add t13, t2
    t15: i32 = add t14, Constant:i32<-1>
  t17: ch = CopyToReg t0, Register:i32 %0, t15


Legalizing node: t16: i32 = Register %0
Ignoring node results
Legally typed node: t16: i32 = Register %0

Legalizing node: t11: i32 = Constant<1>
Analyzing result type: i32
Legal result type
Legally typed node: t11: i32 = Constant<1>

Legalizing node: t6: i32 = Constant<-2>
Analyzing result type: i32
Legal result type
Legally typed node: t6: i32 = Constant<-2>

Legalizing node: t3: i32 = Constant<-1>
Analyzing result type: i32
Legal result type
Legally typed node: t3: i32 = Constant<-1>

Legalizing node: t1: i32 = Register %2
Ignoring node results
Legally typed node: t1: i32 = Register %2

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t2: i32,ch = CopyFromReg t0, Register:i32 %2
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t2: i32,ch = CopyFromReg t0, Register:i32 %2

Legalizing node: t4: i32 = add nsw t2, Constant:i32<-1>
Analyzing result type: i32
Legal result type
Analyzing operand: t2: i32,ch = CopyFromReg t0, Register:i32 %2
Legal operand
Analyzing operand: t3: i32 = Constant<-1>
Legal operand
Legally typed node: t4: i32 = add nsw t2, Constant:i32<-1>

Legalizing node: t5: i33 = zero_extend t4
Analyzing result type: i33
Promote integer result: t5: i33 = zero_extend t4

Creating new node: t18: i64 = zero_extend t4
Legalizing node: t18: i64 = zero_extend t4
Analyzing result type: i64
Expand integer result: t18: i64 = zero_extend t4

Creating constant: t19: i32 = Constant<0>
Legalizing node: t19: i32 = Constant<0>
Analyzing result type: i32
Legal result type
Legally typed node: t19: i32 = Constant<0>

Legalizing node: t7: i32 = add nsw t2, Constant:i32<-2>
Analyzing result type: i32
Legal result type
Analyzing operand: t2: i32,ch = CopyFromReg t0, Register:i32 %2
Legal operand
Analyzing operand: t6: i32 = Constant<-2>
Legal operand
Legally typed node: t7: i32 = add nsw t2, Constant:i32<-2>

Legalizing node: t8: i33 = zero_extend t7
Analyzing result type: i33
Promote integer result: t8: i33 = zero_extend t7

Creating new node: t20: i64 = zero_extend t7
Legalizing node: t9: i33 = mul t5, t8
Analyzing result type: i33
Promote integer result: t9: i33 = mul t5, t8

Creating new node: t21: i64 = mul t18, t20
Legalizing node: t12: i33 = srl t9, Constant:i32<1>
Analyzing result type: i33
Promote integer result: t12: i33 = srl t9, Constant:i32<1>

Creating constant: t22: i64 = Constant<8589934591>
Creating new node: t23: i64 = and t21, Constant:i64<8589934591>
Creating new node: t24: i64 = srl t23, Constant:i32<1>
Legalizing node: t13: i32 = truncate t12
Analyzing result type: i32
Legal result type
Analyzing operand: t12: i33 = srl t9, Constant:i32<1>
Promote integer operand: t13: i32 = truncate t12

Creating new node: t25: i32 = truncate t24
Replacing: t13: i32 = truncate t12
     with: t25: i32 = truncate t24
Legalizing node: t22: i64 = Constant<8589934591>
Analyzing result type: i64
Expand integer result: t22: i64 = Constant<8589934591>

Legalizing node: t20: i64 = zero_extend t7
Analyzing result type: i64
Expand integer result: t20: i64 = zero_extend t7

Legalizing node: t21: i64 = mul t18, t20
Analyzing result type: i64
Expand integer result: t21: i64 = mul t18, t20

Creating new node: t27: i32 = extract_element t18, Constant:i32<1>
Creating new node: t28: i32 = extract_element t18, Constant:i32<0>
Creating new node: t29: i32 = extract_element t20, Constant:i32<1>
Creating new node: t30: i32 = extract_element t20, Constant:i32<0>
Creating new node: t32: ch,glue = CopyToReg t0, Register:i32 $r10, t28
Creating new node: t34: ch,glue = CopyToReg t32, Register:i32 $r11, t27
Creating new node: t36: ch,glue = CopyToReg t34, Register:i32 $r12, t30
Creating new node: t38: ch,glue = CopyToReg t36, Register:i32 $r13, t29
Creating new node: t39: ch,glue = <<Unknown Target Node #302>> t0, ExternalSymbol:i32'__muldi3', Register:i32 $r10, Register:i32 $r11, Register:i32 $r12, Register:i32 $r13
Creating new node: t40: i32,ch = CopyFromReg t39, Register:i32 $r10
Creating new node: t41: i32,ch = CopyFromReg t39, Register:i32 $r11
Creating new node: t42: i64 = build_pair t40, t41
Creating new node: t43: i32 = truncate t42
Creating constant: t44: i32 = Constant<32>
Creating new node: t45: i64 = srl t42, Constant:i32<32>
Creating new node: t46: i32 = truncate t45
Legalizing node: t23: i64 = and t21, Constant:i64<8589934591>
Analyzing result type: i64
Expand integer result: t23: i64 = and t21, Constant:i64<8589934591>

Creating new node: t47: i32 = and t46, Constant:i32<1>
Legalizing node: t24: i64 = srl t23, Constant:i32<1>
Analyzing result type: i64
Expand integer result: t24: i64 = srl t23, Constant:i32<1>

Creating constant: t48: i32 = Constant<31>
Creating new node: t49: i32 = shl t47, Constant:i32<31>
Creating new node: t50: i32 = srl t43, Constant:i32<1>
Creating new node: t51: i32 = or t50, t49
Creating new node: t52: i32 = srl t47, Constant:i32<1>
Legalizing node: t25: i32 = truncate t24
Analyzing result type: i32
Legal result type
Analyzing operand: t24: i64 = srl t23, Constant:i32<1>
Expand integer operand: t25: i32 = truncate t24

Legalizing node: t48: i32 = Constant<31>
Analyzing result type: i32
Legal result type
Legally typed node: t48: i32 = Constant<31>

Legalizing node: t44: i32 = Constant<32>
Analyzing result type: i32
Legal result type
Legally typed node: t44: i32 = Constant<32>

Legalizing node: t37: i32 = Register $r13
Ignoring node results
Legally typed node: t37: i32 = Register $r13

Legalizing node: t35: i32 = Register $r12
Ignoring node results
Legally typed node: t35: i32 = Register $r12

Legalizing node: t33: i32 = Register $r11
Ignoring node results
Legally typed node: t33: i32 = Register $r11

Legalizing node: t31: i32 = Register $r10
Ignoring node results
Legally typed node: t31: i32 = Register $r10

Legalizing node: t26: i32 = ExternalSymbol'__muldi3'
Analyzing result type: i32
Legal result type
Legally typed node: t26: i32 = ExternalSymbol'__muldi3'

Legalizing node: t39: ch,glue = <<Unknown Target Node #302>> t0, ExternalSymbol:i32'__muldi3', Register:i32 $r10, Register:i32 $r11, Register:i32 $r12, Register:i32 $r13
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t26: i32 = ExternalSymbol'__muldi3'
Legal operand
Legally typed node: t39: ch,glue = <<Unknown Target Node #302>> t0, ExternalSymbol:i32'__muldi3', Register:i32 $r10, Register:i32 $r11, Register:i32 $r12, Register:i32 $r13

Legalizing node: t40: i32,ch = CopyFromReg t39, Register:i32 $r10
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t39: ch,glue = <<Unknown Target Node #302>> t0, ExternalSymbol:i32'__muldi3', Register:i32 $r10, Register:i32 $r11, Register:i32 $r12, Register:i32 $r13
Legal operand
Legally typed node: t40: i32,ch = CopyFromReg t39, Register:i32 $r10

Legalizing node: t41: i32,ch = CopyFromReg t39, Register:i32 $r11
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t39: ch,glue = <<Unknown Target Node #302>> t0, ExternalSymbol:i32'__muldi3', Register:i32 $r10, Register:i32 $r11, Register:i32 $r12, Register:i32 $r13
Legal operand
Legally typed node: t41: i32,ch = CopyFromReg t39, Register:i32 $r11

Legalizing node: t42: i64 = build_pair t40, t41
Analyzing result type: i64
Expand integer result: t42: i64 = build_pair t40, t41

Legalizing node: t43: i32 = truncate t42
Analyzing result type: i32
Legal result type
Analyzing operand: t42: i64 = build_pair t40, t41
Expand integer operand: t43: i32 = truncate t42

Legalizing node: t50: i32 = srl t40, Constant:i32<1>
Analyzing result type: i32
Legal result type
Analyzing operand: t40: i32,ch = CopyFromReg t39, Register:i32 $r10
Legal operand
Analyzing operand: t11: i32 = Constant<1>
Legal operand
Legally typed node: t50: i32 = srl t40, Constant:i32<1>

Legalizing node: t45: i64 = srl t42, Constant:i32<32>
Analyzing result type: i64
Expand integer result: t45: i64 = srl t42, Constant:i32<32>

Legalizing node: t46: i32 = truncate t45
Analyzing result type: i32
Legal result type
Analyzing operand: t45: i64 = srl t42, Constant:i32<32>
Expand integer operand: t46: i32 = truncate t45

Legalizing node: t47: i32 = and t41, Constant:i32<1>
Analyzing result type: i32
Legal result type
Analyzing operand: t41: i32,ch = CopyFromReg t39, Register:i32 $r11
Legal operand
Analyzing operand: t11: i32 = Constant<1>
Legal operand
Legally typed node: t47: i32 = and t41, Constant:i32<1>

Legalizing node: t49: i32 = shl t47, Constant:i32<31>
Analyzing result type: i32
Legal result type
Analyzing operand: t47: i32 = and t41, Constant:i32<1>
Legal operand
Analyzing operand: t48: i32 = Constant<31>
Legal operand
Legally typed node: t49: i32 = shl t47, Constant:i32<31>

Legalizing node: t51: i32 = or t50, t49
Analyzing result type: i32
Legal result type
Analyzing operand: t50: i32 = srl t40, Constant:i32<1>
Legal operand
Analyzing operand: t49: i32 = shl t47, Constant:i32<31>
Legal operand
Legally typed node: t51: i32 = or t50, t49

Legalizing node: t14: i32 = add t51, t2
Analyzing result type: i32
Legal result type
Analyzing operand: t51: i32 = or t50, t49
Legal operand
Analyzing operand: t2: i32,ch = CopyFromReg t0, Register:i32 %2
Legal operand
Legally typed node: t14: i32 = add t51, t2

Legalizing node: t15: i32 = add t14, Constant:i32<-1>
Analyzing result type: i32
Legal result type
Analyzing operand: t14: i32 = add t51, t2
Legal operand
Analyzing operand: t3: i32 = Constant<-1>
Legal operand
Legally typed node: t15: i32 = add t14, Constant:i32<-1>

Legalizing node: t17: ch = CopyToReg t0, Register:i32 %0, t15
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t15: i32 = add t14, Constant:i32<-1>
Legal operand
Legally typed node: t17: ch = CopyToReg t0, Register:i32 %0, t15

Legalizing node: t65535: ch = handlenode t17
Analyzing result type: ch
Legal result type
Analyzing operand: t17: ch = CopyToReg t0, Register:i32 %0, t15
Legal operand
Legally typed node: t65535: ch = handlenode t17

Legalizing node: t52: i32 = srl t47, Constant:i32<1>
Analyzing result type: i32
Legal result type
Analyzing operand: t47: i32 = and t41, Constant:i32<1>
Legal operand
Analyzing operand: t11: i32 = Constant<1>
Legal operand
Legally typed node: t52: i32 = srl t47, Constant:i32<1>

Type-legalized selection DAG: %bb.1 'acc:for.body.preheader'
SelectionDAG has 22 nodes:
  t0: ch = EntryToken
  t39: ch,glue = <<Unknown Target Node #302>> t0, ExternalSymbol:i32'__muldi3', Register:i32 $r10, Register:i32 $r11, Register:i32 $r12, Register:i32 $r13
            t40: i32,ch = CopyFromReg t39, Register:i32 $r10
          t50: i32 = srl t40, Constant:i32<1>
              t41: i32,ch = CopyFromReg t39, Register:i32 $r11
            t47: i32 = and t41, Constant:i32<1>
          t49: i32 = shl t47, Constant:i32<31>
        t51: i32 = or t50, t49
        t2: i32,ch = CopyFromReg t0, Register:i32 %2
      t14: i32 = add t51, t2
    t15: i32 = add t14, Constant:i32<-1>
  t17: ch = CopyToReg t0, Register:i32 %0, t15



Combining: t51: i32 = or t50, t49

Replacing.2 t47: i32 = and t41, Constant:i32<1>

With: t41: i32,ch = CopyFromReg t39, Register:i32 $r11


Combining: t51: i32 = or t50, t49

Combining: t50: i32 = srl t40, Constant:i32<1>

Combining: t49: i32 = shl t41, Constant:i32<31>

Combining: t48: i32 = Constant<31>

Combining: t41: i32,ch = CopyFromReg t39, Register:i32 $r11

Combining: t40: i32,ch = CopyFromReg t39, Register:i32 $r10

Combining: t39: ch,glue = <<Unknown Target Node #302>> t0, ExternalSymbol:i32'__muldi3', Register:i32 $r10, Register:i32 $r11, Register:i32 $r12, Register:i32 $r13

Combining: t37: i32 = Register $r13

Combining: t35: i32 = Register $r12

Combining: t33: i32 = Register $r11

Combining: t31: i32 = Register $r10

Combining: t26: i32 = ExternalSymbol'__muldi3'

Combining: t17: ch = CopyToReg t0, Register:i32 %0, t15

Combining: t16: i32 = Register %0

Combining: t15: i32 = add t14, Constant:i32<-1>

Combining: t14: i32 = add t51, t2

Combining: t11: i32 = Constant<1>

Combining: t3: i32 = Constant<-1>

Combining: t2: i32,ch = CopyFromReg t0, Register:i32 %2

Combining: t1: i32 = Register %2

Combining: t0: ch = EntryToken
Optimized type-legalized selection DAG: %bb.1 'acc:for.body.preheader'
SelectionDAG has 21 nodes:
  t0: ch = EntryToken
  t39: ch,glue = <<Unknown Target Node #302>> t0, ExternalSymbol:i32'__muldi3', Register:i32 $r10, Register:i32 $r11, Register:i32 $r12, Register:i32 $r13
            t40: i32,ch = CopyFromReg t39, Register:i32 $r10
          t50: i32 = srl t40, Constant:i32<1>
            t41: i32,ch = CopyFromReg t39, Register:i32 $r11
          t49: i32 = shl t41, Constant:i32<31>
        t51: i32 = or t50, t49
        t2: i32,ch = CopyFromReg t0, Register:i32 %2
      t14: i32 = add t51, t2
    t15: i32 = add t14, Constant:i32<-1>
  t17: ch = CopyToReg t0, Register:i32 %0, t15



Legalizing: t17: ch = CopyToReg t0, Register:i32 %0, t15
Legal node: nothing to do

Legalizing: t15: i32 = add t14, Constant:i32<-1>
Legal node: nothing to do

Legalizing: t14: i32 = add t51, t2
Legal node: nothing to do

Legalizing: t51: i32 = or t50, t49
Legal node: nothing to do

Legalizing: t50: i32 = srl t40, Constant:i32<1>
Legal node: nothing to do

Legalizing: t49: i32 = shl t41, Constant:i32<31>
Legal node: nothing to do

Legalizing: t40: i32,ch = CopyFromReg t39, Register:i32 $r10
Legal node: nothing to do

Legalizing: t41: i32,ch = CopyFromReg t39, Register:i32 $r11
Legal node: nothing to do

Legalizing: t39: ch,glue = <<Unknown Target Node #302>> t0, ExternalSymbol:i32'__muldi3', Register:i32 $r10, Register:i32 $r11, Register:i32 $r12, Register:i32 $r13
Legal node: nothing to do

Legalizing: t2: i32,ch = CopyFromReg t0, Register:i32 %2
Legal node: nothing to do

Legalizing: t48: i32 = Constant<31>
Legal node: nothing to do

Legalizing: t37: i32 = Register $r13

Legalizing: t35: i32 = Register $r12

Legalizing: t33: i32 = Register $r11

Legalizing: t31: i32 = Register $r10

Legalizing: t26: i32 = ExternalSymbol'__muldi3'
Legal node: nothing to do

Legalizing: t16: i32 = Register %0

Legalizing: t11: i32 = Constant<1>
Legal node: nothing to do

Legalizing: t3: i32 = Constant<-1>
Legal node: nothing to do

Legalizing: t1: i32 = Register %2

Legalizing: t0: ch = EntryToken
Legal node: nothing to do
Legalized selection DAG: %bb.1 'acc:for.body.preheader'
SelectionDAG has 21 nodes:
  t0: ch = EntryToken
  t39: ch,glue = <<Unknown Target Node #302>> t0, ExternalSymbol:i32'__muldi3', Register:i32 $r10, Register:i32 $r11, Register:i32 $r12, Register:i32 $r13
            t40: i32,ch = CopyFromReg t39, Register:i32 $r10
          t50: i32 = srl t40, Constant:i32<1>
            t41: i32,ch = CopyFromReg t39, Register:i32 $r11
          t49: i32 = shl t41, Constant:i32<31>
        t51: i32 = or t50, t49
        t2: i32,ch = CopyFromReg t0, Register:i32 %2
      t14: i32 = add t51, t2
    t15: i32 = add t14, Constant:i32<-1>
  t17: ch = CopyToReg t0, Register:i32 %0, t15



Legalizing: t17: ch = CopyToReg t0, Register:i32 %0, t15
Legal node: nothing to do

Combining: t17: ch = CopyToReg t0, Register:i32 %0, t15

Legalizing: t15: i32 = add t14, Constant:i32<-1>
Legal node: nothing to do

Combining: t15: i32 = add t14, Constant:i32<-1>

Legalizing: t14: i32 = add t51, t2
Legal node: nothing to do

Combining: t14: i32 = add t51, t2

Legalizing: t51: i32 = or t50, t49
Legal node: nothing to do

Combining: t51: i32 = or t50, t49

Legalizing: t50: i32 = srl t40, Constant:i32<1>
Legal node: nothing to do

Combining: t50: i32 = srl t40, Constant:i32<1>

Legalizing: t49: i32 = shl t41, Constant:i32<31>
Legal node: nothing to do

Combining: t49: i32 = shl t41, Constant:i32<31>

Legalizing: t40: i32,ch = CopyFromReg t39, Register:i32 $r10
Legal node: nothing to do

Combining: t40: i32,ch = CopyFromReg t39, Register:i32 $r10

Legalizing: t41: i32,ch = CopyFromReg t39, Register:i32 $r11
Legal node: nothing to do

Combining: t41: i32,ch = CopyFromReg t39, Register:i32 $r11

Legalizing: t39: ch,glue = <<Unknown Target Node #302>> t0, ExternalSymbol:i32'__muldi3', Register:i32 $r10, Register:i32 $r11, Register:i32 $r12, Register:i32 $r13
Legal node: nothing to do

Combining: t39: ch,glue = <<Unknown Target Node #302>> t0, ExternalSymbol:i32'__muldi3', Register:i32 $r10, Register:i32 $r11, Register:i32 $r12, Register:i32 $r13

Legalizing: t2: i32,ch = CopyFromReg t0, Register:i32 %2
Legal node: nothing to do

Combining: t2: i32,ch = CopyFromReg t0, Register:i32 %2

Legalizing: t48: i32 = Constant<31>
Legal node: nothing to do

Combining: t48: i32 = Constant<31>

Legalizing: t37: i32 = Register $r13

Combining: t37: i32 = Register $r13

Legalizing: t35: i32 = Register $r12

Combining: t35: i32 = Register $r12

Legalizing: t33: i32 = Register $r11

Combining: t33: i32 = Register $r11

Legalizing: t31: i32 = Register $r10

Combining: t31: i32 = Register $r10

Legalizing: t26: i32 = ExternalSymbol'__muldi3'
Legal node: nothing to do

Combining: t26: i32 = ExternalSymbol'__muldi3'

Legalizing: t16: i32 = Register %0

Combining: t16: i32 = Register %0

Legalizing: t11: i32 = Constant<1>
Legal node: nothing to do

Combining: t11: i32 = Constant<1>

Legalizing: t3: i32 = Constant<-1>
Legal node: nothing to do

Combining: t3: i32 = Constant<-1>

Legalizing: t1: i32 = Register %2

Combining: t1: i32 = Register %2

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.1 'acc:for.body.preheader'
SelectionDAG has 21 nodes:
  t0: ch = EntryToken
  t39: ch,glue = <<Unknown Target Node #302>> t0, ExternalSymbol:i32'__muldi3', Register:i32 $r10, Register:i32 $r11, Register:i32 $r12, Register:i32 $r13
            t40: i32,ch = CopyFromReg t39, Register:i32 $r10
          t50: i32 = srl t40, Constant:i32<1>
            t41: i32,ch = CopyFromReg t39, Register:i32 $r11
          t49: i32 = shl t41, Constant:i32<31>
        t51: i32 = or t50, t49
        t2: i32,ch = CopyFromReg t0, Register:i32 %2
      t14: i32 = add t51, t2
    t15: i32 = add t14, Constant:i32<-1>
  t17: ch = CopyToReg t0, Register:i32 %0, t15


===== Instruction selection begins: %bb.1 'for.body.preheader'

ISEL: Starting selection on root node: t17: ch = CopyToReg t0, Register:i32 %0, t15

ISEL: Starting selection on root node: t15: i32 = add t14, Constant:i32<-1>
ISEL: Starting pattern match
  Initial Opcode index to 521
Creating constant: t53: i32 = TargetConstant<-1>
  Morphed node: t15: i32 = ADDI t14, TargetConstant:i32<-1>
ISEL: Match complete!

ISEL: Starting selection on root node: t14: i32 = add t51, t2
ISEL: Starting pattern match
  Initial Opcode index to 521
  Match failed at index 526
  Continuing at 559
  Morphed node: t14: i32 = ADD t51, t2
ISEL: Match complete!

ISEL: Starting selection on root node: t51: i32 = or t50, t49
ISEL: Starting pattern match
  Initial Opcode index to 675
  Match failed at index 680
  Continuing at 696
  Morphed node: t51: i32 = OR t50, t49
ISEL: Match complete!

ISEL: Starting selection on root node: t50: i32 = srl t40, Constant:i32<1>
ISEL: Starting pattern match
  Initial Opcode index to 777
Creating constant: t54: i32 = TargetConstant<1>
  Morphed node: t50: i32 = SRLI t40, TargetConstant:i32<1>
ISEL: Match complete!

ISEL: Starting selection on root node: t49: i32 = shl t41, Constant:i32<31>
ISEL: Starting pattern match
  Initial Opcode index to 743
Creating constant: t55: i32 = TargetConstant<31>
  Morphed node: t49: i32 = SLLI t41, TargetConstant:i32<31>
ISEL: Match complete!

ISEL: Starting selection on root node: t40: i32,ch = CopyFromReg t39, Register:i32 $r10

ISEL: Starting selection on root node: t41: i32,ch = CopyFromReg t39, Register:i32 $r11

ISEL: Starting selection on root node: t39: ch,glue = <<Unknown Target Node #302>> t0, ExternalSymbol:i32'__muldi3', Register:i32 $r10, Register:i32 $r11, Register:i32 $r12, Register:i32 $r13
ISEL: Starting pattern match
  Initial Opcode index to 1119
  Match failed at index 1123
LLVM ERROR: Cannot select: t39: ch,glue = <<Unknown Target Node #302>> t0, ExternalSymbol:i32'__muldi3', Register:i32 $r10, Register:i32 $r11, Register:i32 $r12, Register:i32 $r13
  t26: i32 = ExternalSymbol'__muldi3'
  t31: i32 = Register $r10
  t33: i32 = Register $r11
  t35: i32 = Register $r12
  t37: i32 = Register $r13
In function: acc
